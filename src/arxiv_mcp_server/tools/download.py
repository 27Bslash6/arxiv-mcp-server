"""Download functionality for the arXiv MCP server."""

import asyncio
import json
import logging
import shutil
import subprocess
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any

import httpx
import mcp.types as types
from markdownify import markdownify as md

from ..config import Settings, get_arxiv_client

logger = logging.getLogger("arxiv-mcp-server")
settings = Settings()

# Global dictionary to track conversion status
conversion_statuses: dict[str, Any] = {}


@dataclass
class ConversionStatus:
    """Track the status of a PDF to Markdown conversion."""

    paper_id: str
    status: str  # 'downloading', 'converting', 'success', 'error'
    started_at: datetime
    completed_at: datetime | None = None
    error: str | None = None


download_tool = types.Tool(
    name="download_paper",
    description="Download a paper and create a resource for it",
    inputSchema={
        "type": "object",
        "properties": {
            "paper_id": {
                "type": "string",
                "description": "The arXiv ID of the paper to download",
            },
            "check_status": {
                "type": "boolean",
                "description": "If true, only check conversion status without downloading",
                "default": False,
            },
            "format": {
                "type": "string",
                "enum": ["auto", "pdf", "html"],
                "description": "Download format: 'auto' tries HTML first then PDF fallback, 'html' for HTML only, 'pdf' for PDF only",
                "default": "auto",
            },
        },
        "required": ["paper_id"],
    },
)


def get_paper_path(paper_id: str, suffix: str = ".md") -> Path:
    """Get the absolute file path for a paper with given suffix."""
    storage_path = Path(settings.STORAGE_PATH)
    storage_path.mkdir(parents=True, exist_ok=True)
    return storage_path / f"{paper_id}{suffix}"


async def fetch_html_as_markdown(paper_id: str) -> Path:
    """Fetch arXiv HTML paper and convert to markdown.

    arXiv serves semantic HTML at arxiv.org/html/{id} for recent papers,
    producing cleaner markdown than PDF extraction.

    Raises httpx.HTTPStatusError on non-2xx responses (e.g. 404 for papers without HTML).
    """
    url = f"https://arxiv.org/html/{paper_id}"
    async with httpx.AsyncClient(follow_redirects=True, timeout=60.0) as client:
        resp = await client.get(url)
        resp.raise_for_status()

    markdown = md(resp.text, heading_style="ATX", strip=["img", "script", "style"])
    md_path = get_paper_path(paper_id, ".md")
    md_path.write_text(markdown, encoding="utf-8")
    return md_path


def convert_pdf_to_markdown(paper_id: str, pdf_path: Path) -> None:
    """Convert PDF to Markdown via the unpdf Rust binary."""
    try:
        unpdf = shutil.which("unpdf")
        if not unpdf:
            raise FileNotFoundError("unpdf binary not found on PATH")

        md_path = get_paper_path(paper_id, ".md")
        logger.info(f"Starting conversion for {paper_id}")

        result = subprocess.run(
            [unpdf, "markdown", "--cleanup", "aggressive", str(pdf_path), "-o", str(md_path)],
            capture_output=True,
            text=True,
            timeout=120,
        )

        if result.returncode != 0:
            raise RuntimeError(f"unpdf exited {result.returncode}: {result.stderr.strip()}")

        if not md_path.exists() or md_path.stat().st_size == 0:
            raise RuntimeError("unpdf produced no output")

        status = conversion_statuses.get(paper_id)
        if status:
            status.status = "success"
            status.completed_at = datetime.now()

        pdf_path.unlink(missing_ok=True)
        logger.info(f"Conversion completed for {paper_id}")

    except Exception as e:
        logger.error(f"Conversion failed for {paper_id}: {str(e)}")
        status = conversion_statuses.get(paper_id)
        if status:
            status.status = "error"
            status.completed_at = datetime.now()
            status.error = str(e)
    finally:
        conversion_statuses.pop(paper_id, None)


async def handle_download(arguments: dict[str, Any]) -> list[types.TextContent]:
    """Handle paper download and conversion requests."""
    try:
        paper_id = arguments["paper_id"]
        check_status = arguments.get("check_status", False)

        # If only checking status
        if check_status:
            status = conversion_statuses.get(paper_id)
            if not status:
                if get_paper_path(paper_id, ".md").exists():
                    return [
                        types.TextContent(
                            type="text",
                            text=json.dumps(
                                {
                                    "status": "success",
                                    "message": "Paper is ready",
                                    "resource_uri": f"file://{get_paper_path(paper_id, '.md')}",
                                }
                            ),
                        )
                    ]
                return [
                    types.TextContent(
                        type="text",
                        text=json.dumps(
                            {
                                "status": "unknown",
                                "message": "No download or conversion in progress",
                            }
                        ),
                    )
                ]

            return [
                types.TextContent(
                    type="text",
                    text=json.dumps(
                        {
                            "status": status.status,
                            "started_at": status.started_at.isoformat(),
                            "completed_at": (status.completed_at.isoformat() if status.completed_at else None),
                            "error": status.error,
                            "message": f"Paper conversion {status.status}",
                        }
                    ),
                )
            ]

        # Check if paper is already converted
        if get_paper_path(paper_id, ".md").exists():
            return [
                types.TextContent(
                    type="text",
                    text=json.dumps(
                        {
                            "status": "success",
                            "message": "Paper already available",
                            "resource_uri": f"file://{get_paper_path(paper_id, '.md')}",
                        }
                    ),
                )
            ]

        # Check if already in progress
        if paper_id in conversion_statuses:
            status = conversion_statuses[paper_id]
            return [
                types.TextContent(
                    type="text",
                    text=json.dumps(
                        {
                            "status": status.status,
                            "message": f"Paper conversion {status.status}",
                            "started_at": status.started_at.isoformat(),
                        }
                    ),
                )
            ]

        # Start new download and conversion
        fmt = arguments.get("format", "auto")

        # Try HTML download for "auto" and "html" formats
        if fmt in ("auto", "html"):
            try:
                logger.info(f"Fetching HTML for {paper_id}")
                md_path = await fetch_html_as_markdown(paper_id)
                return [
                    types.TextContent(
                        type="text",
                        text=json.dumps(
                            {
                                "status": "success",
                                "message": "Paper downloaded from HTML",
                                "resource_uri": f"file://{md_path}",
                            }
                        ),
                    )
                ]
            except httpx.HTTPStatusError as e:
                if fmt == "html":
                    return [
                        types.TextContent(
                            type="text",
                            text=json.dumps(
                                {
                                    "status": "error",
                                    "message": f"HTML version not available (HTTP {e.response.status_code})",
                                }
                            ),
                        )
                    ]
                logger.info(f"HTML not available for {paper_id} (HTTP {e.response.status_code}), falling back to PDF")
            except Exception as e:
                if fmt == "html":
                    return [
                        types.TextContent(
                            type="text",
                            text=json.dumps(
                                {
                                    "status": "error",
                                    "message": f"HTML download failed: {str(e)}",
                                }
                            ),
                        )
                    ]
                logger.info(f"HTML fetch failed for {paper_id}: {e}, falling back to PDF")

        # PDF download path (for "pdf" format or "auto" fallback)
        import arxiv

        pdf_path = get_paper_path(paper_id, ".pdf")
        client = get_arxiv_client()

        # Initialize status
        conversion_statuses[paper_id] = ConversionStatus(paper_id=paper_id, status="downloading", started_at=datetime.now())

        # Download PDF
        paper = next(client.results(arxiv.Search(id_list=[paper_id])))
        paper.download_pdf(dirpath=pdf_path.parent, filename=pdf_path.name)

        # Update status and start conversion
        status = conversion_statuses[paper_id]
        status.status = "converting"

        # Start conversion in thread
        asyncio.create_task(asyncio.to_thread(convert_pdf_to_markdown, paper_id, pdf_path))

        return [
            types.TextContent(
                type="text",
                text=json.dumps(
                    {
                        "status": "converting",
                        "message": "Paper downloaded, conversion started",
                        "started_at": status.started_at.isoformat(),
                    }
                ),
            )
        ]

    except StopIteration:
        return [
            types.TextContent(
                type="text",
                text=json.dumps(
                    {
                        "status": "error",
                        "message": f"Paper {paper_id} not found on arXiv",
                    }
                ),
            )
        ]
    except Exception as e:
        return [
            types.TextContent(
                type="text",
                text=json.dumps({"status": "error", "message": f"Error: {str(e)}"}),
            )
        ]
